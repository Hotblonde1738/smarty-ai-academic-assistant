# SmartyPants-AI Project Rules

## Project Context

This is a Netlify-deployed web application for SmartyPants-AI Academic Assistant. The project is live at https://getsmartyai.space

## Development Environment

- **Platform**: Netlify (Serverless)
- **Local Environment**: Windows PowerShell
- **No Local Server**: This project doesn't use a local development server
- **File Structure**: Static HTML/CSS/JS with Netlify Functions

## Important Rules

### 1. No Local Server Commands

- **NEVER** suggest running `node index.js` or similar local server commands
- **NEVER** use `run_terminal_cmd` to start servers
- The `index.js` file is for Netlify Functions, not local development
- All development is done by editing files directly

### 2. Windows PowerShell Commands

- **ALWAYS** provide commands for Windows PowerShell
- **NEVER** use Unix/Linux commands (like `rm -rf`, `ls`, etc.)
- Use PowerShell equivalents:
  - `Remove-Item -Recurse -Force` instead of `rm -rf`
  - `Get-ChildItem` instead of `ls`
  - `New-Item` instead of `mkdir`
  - `Copy-Item` instead of `cp`

### 3. Command Execution

- **ALWAYS** set `require_user_approval: true` for terminal commands
- **NEVER** auto-execute commands without user approval
- Provide commands for the user to run manually
- Explain what each command does before suggesting it

### 4. File Operations

- Use `edit_file` and `search_replace` for code changes
- Use `read_file` to examine existing code
- Use `list_dir` to explore project structure
- Use `file_search` to find specific files

### 5. Project Structure

- **Root**: Configuration files (package.json, netlify.toml, README.md)
- **public/**: Main web application files
- **netlify/functions/**: Serverless functions for backend
- **No build process**: Direct file editing and deployment

### 6. Deployment

- Changes are deployed automatically via Netlify
- No build commands needed
- File changes trigger automatic deployment
- Check https://getsmartyai.space for live updates

### 7. Development Workflow

1. Edit files using appropriate tools
2. Provide PowerShell commands for user to run (if needed)
3. Test changes on live site
4. No local server required

### 8. Common Tasks

- **Git operations**: Use PowerShell Git commands
- **File management**: Use PowerShell file commands
- **Package management**: Use `npm` commands in PowerShell
- **Environment setup**: Focus on file editing, not server setup

### 9. Error Handling

- If suggesting commands, always explain the purpose
- Provide alternative approaches if commands fail
- Consider Windows-specific issues and solutions

### 10. Communication

- Always clarify that this is a Netlify project
- Remind users to check the live site for changes
- Explain that no local server is needed for development

## Example Command Format

```powershell
# Example: Remove a directory
Remove-Item -Recurse -Force "directory_name"

# Example: List files
Get-ChildItem

# Example: Create directory
New-Item -ItemType Directory -Name "new_directory"
```

Remember: This is a static site deployed on Netlify. Focus on file editing and provide Windows PowerShell commands when needed.

## Git Commit Message Rules

### Technical but Concise Commit Messages

- **ALWAYS** use technical but concise commit messages
- **INCLUDE** key technical details that matter for development
- **FOCUS** on what was implemented or fixed
- **KEEP** messages under 200 characters when possible
- **AVOID** overly verbose descriptions

### Commit Message Format

```
feat: [technical feature description]
fix: [technical fix description]
update: [technical update description]
refactor: [technical refactor description]
```

### Examples of Good Commit Messages

- `feat: implement Supabase database integration`
- `feat: add unified syllabus service with dual storage`
- `fix: resolve CORS issues in API endpoints`
- `update: improve error handling in payment flow`
- `refactor: consolidate UI controller logic`

### Examples of Bad Commit Messages (Avoid)

- `feat: implement comprehensive Supabase client integration with proper CORS handling, error management, and detailed logging for debugging and monitoring purposes`
- `fix: resolve complex async/await promise rejection chain in syllabus service with proper error propagation`
- `update: refactor entire UI controller architecture with proper event delegation and state management patterns`

### Why This Matters

- Technical details help developers understand changes
- Concise messages are easier to scan and understand
- Focus on implementation without being overly verbose
- Balance between technical accuracy and readability

### When to Use Detailed Messages

- In pull request descriptions
- In code comments and documentation
- In development notes
- When explaining complex technical decisions

Remember: Be technical but concise. Include key implementation details without being verbose.
